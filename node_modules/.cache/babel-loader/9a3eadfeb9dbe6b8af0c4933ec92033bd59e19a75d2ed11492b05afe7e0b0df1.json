{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n//      \n\nvar charCodeOfDot = \".\".charCodeAt(0);\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp(\n// Match anything that isn't a dot or bracket.\n\"[^.[\\\\]]+\" + \"|\" +\n// Or match property names within brackets.\n\"\\\\[(?:\" +\n// Match a non-string expression.\n\"([^\\\"'][^[]*)\" + \"|\" +\n// Or match strings (supports escaping characters).\n\"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" +\n// Or match \"\" as the space between consecutive dots or empty brackets.\n\"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = function stringToPath(string) {\n  var result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    var key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\nvar keysCache = {};\nvar keysRegex = /[.[\\]]+/;\nvar toPath = function toPath(key) {\n  if (key === null || key === undefined || !key.length) {\n    return [];\n  }\n  if (typeof key !== \"string\") {\n    throw new Error(\"toPath() expects a string\");\n  }\n  if (keysCache[key] == null) {\n    /**\n     * The following patch fixes issue 456, introduced since v4.20.3:\n     *\n     * Before v4.20.3, i.e. in v4.20.2, a `key` like 'choices[]' would map to ['choices']\n     * (e.g. an array of choices used where 'choices[]' is name attribute of an input of type checkbox).\n     *\n     * Since v4.20.3, a `key` like 'choices[]' would map to ['choices', ''] which is wrong and breaks\n     * this kind of inputs e.g. in React.\n     *\n     * v4.20.3 introduced an unwanted breaking change, this patch fixes it, see the issue at the link below.\n     *\n     * @see https://github.com/final-form/final-form/issues/456\n     */\n    if (key.endsWith(\"[]\")) {\n      // v4.20.2 (a `key` like 'choices[]' should map to ['choices'], which is fine).\n      keysCache[key] = key.split(keysRegex).filter(Boolean);\n    } else {\n      // v4.20.3 (a `key` like 'choices[]' maps to ['choices', ''], which breaks applications relying on inputs like `<input type=\"checkbox\" name=\"choices[]\" />`).\n      keysCache[key] = stringToPath(key);\n    }\n  }\n  return keysCache[key];\n};\n\n//      \nvar getIn = function getIn(state, complexKey) {\n  // Intentionally using iteration rather than recursion\n  var path = toPath(complexKey);\n  var current = state;\n  for (var i = 0; i < path.length; i++) {\n    var key = path[i];\n    if (current === undefined || current === null || typeof current !== \"object\" || Array.isArray(current) && isNaN(key)) {\n      return undefined;\n    }\n    current = current[key];\n  }\n  return current;\n};\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar setInRecursor = function setInRecursor(current, index, path, value, destroyArrays) {\n  if (index >= path.length) {\n    // end of recursion\n    return value;\n  }\n  var key = path[index];\n\n  // determine type of key\n  if (isNaN(key)) {\n    var _extends2;\n    // object set\n    if (current === undefined || current === null) {\n      var _ref;\n      // recurse\n      var _result = setInRecursor(undefined, index + 1, path, value, destroyArrays);\n\n      // delete or create an object\n      return _result === undefined ? undefined : (_ref = {}, _ref[key] = _result, _ref);\n    }\n    if (Array.isArray(current)) {\n      throw new Error(\"Cannot set a non-numeric property on an array\");\n    }\n    // current exists, so make a copy of all its values, and add/update the new one\n    var _result2 = setInRecursor(current[key], index + 1, path, value, destroyArrays);\n    if (_result2 === undefined) {\n      var numKeys = Object.keys(current).length;\n      if (current[key] === undefined && numKeys === 0) {\n        // object was already empty\n        return undefined;\n      }\n      if (current[key] !== undefined && numKeys <= 1) {\n        // only key we had was the one we are deleting\n        if (!isNaN(path[index - 1]) && !destroyArrays) {\n          // we are in an array, so return an empty object\n          return {};\n        } else {\n          return undefined;\n        }\n      }\n      current[key];\n      var _final = _objectWithoutPropertiesLoose(current, [key].map(_toPropertyKey));\n      return _final;\n    }\n    // set result in key\n    return _extends({}, current, (_extends2 = {}, _extends2[key] = _result2, _extends2));\n  }\n  // array set\n  var numericKey = Number(key);\n  if (current === undefined || current === null) {\n    // recurse\n    var _result3 = setInRecursor(undefined, index + 1, path, value, destroyArrays);\n\n    // if nothing returned, delete it\n    if (_result3 === undefined) {\n      return undefined;\n    }\n\n    // create an array\n    var _array = [];\n    _array[numericKey] = _result3;\n    return _array;\n  }\n  if (!Array.isArray(current)) {\n    throw new Error(\"Cannot set a numeric property on an object\");\n  }\n  // recurse\n  var existingValue = current[numericKey];\n  var result = setInRecursor(existingValue, index + 1, path, value, destroyArrays);\n\n  // current exists, so make a copy of all its values, and add/update the new one\n  var array = [].concat(current);\n  if (destroyArrays && result === undefined) {\n    array.splice(numericKey, 1);\n    if (array.length === 0) {\n      return undefined;\n    }\n  } else {\n    array[numericKey] = result;\n  }\n  return array;\n};\nvar setIn = function setIn(state, key, value, destroyArrays) {\n  if (destroyArrays === void 0) {\n    destroyArrays = false;\n  }\n  if (state === undefined || state === null) {\n    throw new Error(\"Cannot call setIn() with \" + String(state) + \" state\");\n  }\n  if (key === undefined || key === null) {\n    throw new Error(\"Cannot call setIn() with \" + String(key) + \" key\");\n  }\n  // Recursive function needs to accept and return State, but public API should\n  // only deal with Objects\n  return setInRecursor(state, 0, toPath(key), value, destroyArrays);\n};\nvar FORM_ERROR = \"FINAL_FORM/form-error\";\nvar ARRAY_ERROR = \"FINAL_FORM/array-error\";\n\n//      \n\n/**\n * Converts internal field state to published field state\n */\nfunction publishFieldState(formState, field) {\n  var errors = formState.errors,\n    initialValues = formState.initialValues,\n    lastSubmittedValues = formState.lastSubmittedValues,\n    submitErrors = formState.submitErrors,\n    submitFailed = formState.submitFailed,\n    submitSucceeded = formState.submitSucceeded,\n    submitting = formState.submitting,\n    values = formState.values;\n  var active = field.active,\n    blur = field.blur,\n    change = field.change,\n    data = field.data,\n    focus = field.focus,\n    modified = field.modified,\n    modifiedSinceLastSubmit = field.modifiedSinceLastSubmit,\n    name = field.name,\n    touched = field.touched,\n    validating = field.validating,\n    visited = field.visited;\n  var value = getIn(values, name);\n  var error = getIn(errors, name);\n  if (error && error[ARRAY_ERROR]) {\n    error = error[ARRAY_ERROR];\n  }\n  var submitError = submitErrors && getIn(submitErrors, name);\n  var initial = initialValues && getIn(initialValues, name);\n  var pristine = field.isEqual(initial, value);\n  var dirtySinceLastSubmit = !!(lastSubmittedValues && !field.isEqual(getIn(lastSubmittedValues, name), value));\n  var valid = !error && !submitError;\n  return {\n    active: active,\n    blur: blur,\n    change: change,\n    data: data,\n    dirty: !pristine,\n    dirtySinceLastSubmit: dirtySinceLastSubmit,\n    error: error,\n    focus: focus,\n    initial: initial,\n    invalid: !valid,\n    length: Array.isArray(value) ? value.length : undefined,\n    modified: modified,\n    modifiedSinceLastSubmit: modifiedSinceLastSubmit,\n    name: name,\n    pristine: pristine,\n    submitError: submitError,\n    submitFailed: submitFailed,\n    submitSucceeded: submitSucceeded,\n    submitting: submitting,\n    touched: touched,\n    valid: valid,\n    value: value,\n    visited: visited,\n    validating: validating\n  };\n}\n\n//      \nvar fieldSubscriptionItems = [\"active\", \"data\", \"dirty\", \"dirtySinceLastSubmit\", \"error\", \"initial\", \"invalid\", \"length\", \"modified\", \"modifiedSinceLastSubmit\", \"pristine\", \"submitError\", \"submitFailed\", \"submitSucceeded\", \"submitting\", \"touched\", \"valid\", \"value\", \"visited\", \"validating\"];\n\n//      \n\nvar shallowEqual = function shallowEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== \"object\" || !a || typeof b !== \"object\" || !b) {\n    return false;\n  }\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b);\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n    if (!bHasOwnProperty(key) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n//      \nfunction subscriptionFilter(dest, src, previous, subscription, keys, shallowEqualKeys) {\n  var different = false;\n  keys.forEach(function (key) {\n    if (subscription[key]) {\n      dest[key] = src[key];\n      if (!previous || (~shallowEqualKeys.indexOf(key) ? !shallowEqual(src[key], previous[key]) : src[key] !== previous[key])) {\n        different = true;\n      }\n    }\n  });\n  return different;\n}\n\n//      \nvar shallowEqualKeys$1 = [\"data\"];\n\n/**\n * Filters items in a FieldState based on a FieldSubscription\n */\nvar filterFieldState = function filterFieldState(state, previousState, subscription, force) {\n  var result = {\n    blur: state.blur,\n    change: state.change,\n    focus: state.focus,\n    name: state.name\n  };\n  var different = subscriptionFilter(result, state, previousState, subscription, fieldSubscriptionItems, shallowEqualKeys$1) || !previousState;\n  return different || force ? result : undefined;\n};\n\n//      \nvar formSubscriptionItems = [\"active\", \"dirty\", \"dirtyFields\", \"dirtyFieldsSinceLastSubmit\", \"dirtySinceLastSubmit\", \"error\", \"errors\", \"hasSubmitErrors\", \"hasValidationErrors\", \"initialValues\", \"invalid\", \"modified\", \"modifiedSinceLastSubmit\", \"pristine\", \"submitting\", \"submitError\", \"submitErrors\", \"submitFailed\", \"submitSucceeded\", \"touched\", \"valid\", \"validating\", \"values\", \"visited\"];\n\n//      \nvar shallowEqualKeys = [\"touched\", \"visited\"];\n\n/**\n * Filters items in a FormState based on a FormSubscription\n */\nfunction filterFormState(state, previousState, subscription, force) {\n  var result = {};\n  var different = subscriptionFilter(result, state, previousState, subscription, formSubscriptionItems, shallowEqualKeys) || !previousState;\n  return different || force ? result : undefined;\n}\n\n//      \nvar memoize = function memoize(fn) {\n  var lastArgs;\n  var lastResult;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (!lastArgs || args.length !== lastArgs.length || args.some(function (arg, index) {\n      return !shallowEqual(lastArgs[index], arg);\n    })) {\n      lastArgs = args;\n      lastResult = fn.apply(void 0, args);\n    }\n    return lastResult;\n  };\n};\nvar isPromise = function (obj) {\n  return !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof obj.then === \"function\";\n};\nvar version = \"4.20.10\";\nvar configOptions = [\"debug\", \"initialValues\", \"keepDirtyOnReinitialize\", \"mutators\", \"onSubmit\", \"validate\", \"validateOnBlur\"];\nvar tripleEquals = function tripleEquals(a, b) {\n  return a === b;\n};\nvar hasAnyError = function hasAnyError(errors) {\n  return Object.keys(errors).some(function (key) {\n    var value = errors[key];\n    if (value && typeof value === \"object\" && !(value instanceof Error)) {\n      return hasAnyError(value);\n    }\n    return typeof value !== \"undefined\";\n  });\n};\nfunction convertToExternalFormState(_ref) {\n  var active = _ref.active,\n    dirtySinceLastSubmit = _ref.dirtySinceLastSubmit,\n    modifiedSinceLastSubmit = _ref.modifiedSinceLastSubmit,\n    error = _ref.error,\n    errors = _ref.errors,\n    initialValues = _ref.initialValues,\n    pristine = _ref.pristine,\n    submitting = _ref.submitting,\n    submitFailed = _ref.submitFailed,\n    submitSucceeded = _ref.submitSucceeded,\n    submitError = _ref.submitError,\n    submitErrors = _ref.submitErrors,\n    valid = _ref.valid,\n    validating = _ref.validating,\n    values = _ref.values;\n  return {\n    active: active,\n    dirty: !pristine,\n    dirtySinceLastSubmit: dirtySinceLastSubmit,\n    modifiedSinceLastSubmit: modifiedSinceLastSubmit,\n    error: error,\n    errors: errors,\n    hasSubmitErrors: !!(submitError || submitErrors && hasAnyError(submitErrors)),\n    hasValidationErrors: !!(error || hasAnyError(errors)),\n    invalid: !valid,\n    initialValues: initialValues,\n    pristine: pristine,\n    submitting: submitting,\n    submitFailed: submitFailed,\n    submitSucceeded: submitSucceeded,\n    submitError: submitError,\n    submitErrors: submitErrors,\n    valid: valid,\n    validating: validating > 0,\n    values: values\n  };\n}\nfunction notifySubscriber(subscriber, subscription, state, lastState, filter, force) {\n  var notification = filter(state, lastState, subscription, force);\n  if (notification) {\n    subscriber(notification);\n    return true;\n  }\n  return false;\n}\nfunction notify(_ref2, state, lastState, filter, force) {\n  var entries = _ref2.entries;\n  Object.keys(entries).forEach(function (key) {\n    var entry = entries[Number(key)];\n    // istanbul ignore next\n    if (entry) {\n      var subscription = entry.subscription,\n        subscriber = entry.subscriber,\n        notified = entry.notified;\n      if (notifySubscriber(subscriber, subscription, state, lastState, filter, force || !notified)) {\n        entry.notified = true;\n      }\n    }\n  });\n}\nfunction createForm(config) {\n  if (!config) {\n    throw new Error(\"No config specified\");\n  }\n  var debug = config.debug,\n    destroyOnUnregister = config.destroyOnUnregister,\n    keepDirtyOnReinitialize = config.keepDirtyOnReinitialize,\n    initialValues = config.initialValues,\n    mutators = config.mutators,\n    onSubmit = config.onSubmit,\n    validate = config.validate,\n    validateOnBlur = config.validateOnBlur;\n  if (!onSubmit) {\n    throw new Error(\"No onSubmit function specified\");\n  }\n  var state = {\n    subscribers: {\n      index: 0,\n      entries: {}\n    },\n    fieldSubscribers: {},\n    fields: {},\n    formState: {\n      asyncErrors: {},\n      dirtySinceLastSubmit: false,\n      modifiedSinceLastSubmit: false,\n      errors: {},\n      initialValues: initialValues && _extends({}, initialValues),\n      invalid: false,\n      pristine: true,\n      submitting: false,\n      submitFailed: false,\n      submitSucceeded: false,\n      resetWhileSubmitting: false,\n      valid: true,\n      validating: 0,\n      values: initialValues ? _extends({}, initialValues) : {}\n    },\n    lastFormState: undefined\n  };\n  var inBatch = 0;\n  var validationPaused = false;\n  var validationBlocked = false;\n  var preventNotificationWhileValidationPaused = false;\n  var nextAsyncValidationKey = 0;\n  var asyncValidationPromises = {};\n  var clearAsyncValidationPromise = function clearAsyncValidationPromise(key) {\n    return function (result) {\n      delete asyncValidationPromises[key];\n      return result;\n    };\n  };\n  var changeValue = function changeValue(state, name, mutate) {\n    var before = getIn(state.formState.values, name);\n    var after = mutate(before);\n    state.formState.values = setIn(state.formState.values, name, after) || {};\n  };\n  var renameField = function renameField(state, from, to) {\n    if (state.fields[from]) {\n      var _extends2, _extends3;\n      state.fields = _extends({}, state.fields, (_extends2 = {}, _extends2[to] = _extends({}, state.fields[from], {\n        name: to,\n        // rebind event handlers\n        blur: function blur() {\n          return api.blur(to);\n        },\n        change: function change(value) {\n          return api.change(to, value);\n        },\n        focus: function focus() {\n          return api.focus(to);\n        },\n        lastFieldState: undefined\n      }), _extends2));\n      delete state.fields[from];\n      state.fieldSubscribers = _extends({}, state.fieldSubscribers, (_extends3 = {}, _extends3[to] = state.fieldSubscribers[from], _extends3));\n      delete state.fieldSubscribers[from];\n      var value = getIn(state.formState.values, from);\n      state.formState.values = setIn(state.formState.values, from, undefined) || {};\n      state.formState.values = setIn(state.formState.values, to, value);\n      delete state.lastFormState;\n    }\n  };\n\n  // bind state to mutators\n  var getMutatorApi = function getMutatorApi(key) {\n    return function () {\n      // istanbul ignore next\n      if (mutators) {\n        // ^^ causes branch coverage warning, but needed to appease the Flow gods\n        var mutatableState = {\n          formState: state.formState,\n          fields: state.fields,\n          fieldSubscribers: state.fieldSubscribers,\n          lastFormState: state.lastFormState\n        };\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var returnValue = mutators[key](args, mutatableState, {\n          changeValue: changeValue,\n          getIn: getIn,\n          renameField: renameField,\n          resetFieldState: api.resetFieldState,\n          setIn: setIn,\n          shallowEqual: shallowEqual\n        });\n        state.formState = mutatableState.formState;\n        state.fields = mutatableState.fields;\n        state.fieldSubscribers = mutatableState.fieldSubscribers;\n        state.lastFormState = mutatableState.lastFormState;\n        runValidation(undefined, function () {\n          notifyFieldListeners();\n          notifyFormListeners();\n        });\n        return returnValue;\n      }\n    };\n  };\n  var mutatorsApi = mutators ? Object.keys(mutators).reduce(function (result, key) {\n    result[key] = getMutatorApi(key);\n    return result;\n  }, {}) : {};\n  var runRecordLevelValidation = function runRecordLevelValidation(setErrors) {\n    var promises = [];\n    if (validate) {\n      var errorsOrPromise = validate(_extends({}, state.formState.values)); // clone to avoid writing\n      if (isPromise(errorsOrPromise)) {\n        promises.push(errorsOrPromise.then(function (errors) {\n          return setErrors(errors, true);\n        }));\n      } else {\n        setErrors(errorsOrPromise, false);\n      }\n    }\n    return promises;\n  };\n  var getValidators = function getValidators(field) {\n    return Object.keys(field.validators).reduce(function (result, index) {\n      var validator = field.validators[Number(index)]();\n      if (validator) {\n        result.push(validator);\n      }\n      return result;\n    }, []);\n  };\n  var runFieldLevelValidation = function runFieldLevelValidation(field, setError) {\n    var promises = [];\n    var validators = getValidators(field);\n    if (validators.length) {\n      var error;\n      validators.forEach(function (validator) {\n        var errorOrPromise = validator(getIn(state.formState.values, field.name), state.formState.values, validator.length === 0 || validator.length === 3 ? publishFieldState(state.formState, state.fields[field.name]) : undefined);\n        if (errorOrPromise && isPromise(errorOrPromise)) {\n          field.validating = true;\n          var promise = errorOrPromise.then(function (error) {\n            if (state.fields[field.name]) {\n              state.fields[field.name].validating = false;\n              setError(error);\n            }\n          }); // errors must be resolved, not rejected\n          promises.push(promise);\n        } else if (!error) {\n          // first registered validator wins\n          error = errorOrPromise;\n        }\n      });\n      setError(error);\n    }\n    return promises;\n  };\n  var runValidation = function runValidation(fieldChanged, callback) {\n    if (validationPaused) {\n      validationBlocked = true;\n      callback();\n      return;\n    }\n    var fields = state.fields,\n      formState = state.formState;\n    var safeFields = _extends({}, fields);\n    var fieldKeys = Object.keys(safeFields);\n    if (!validate && !fieldKeys.some(function (key) {\n      return getValidators(safeFields[key]).length;\n    })) {\n      callback();\n      return; // no validation rules\n    }\n\n    // pare down field keys to actually validate\n    var limitedFieldLevelValidation = false;\n    if (fieldChanged) {\n      var changedField = safeFields[fieldChanged];\n      if (changedField) {\n        var validateFields = changedField.validateFields;\n        if (validateFields) {\n          limitedFieldLevelValidation = true;\n          fieldKeys = validateFields.length ? validateFields.concat(fieldChanged) : [fieldChanged];\n        }\n      }\n    }\n    var recordLevelErrors = {};\n    var asyncRecordLevelErrors = {};\n    var fieldLevelErrors = {};\n    var promises = [].concat(runRecordLevelValidation(function (errors, wasAsync) {\n      if (wasAsync) {\n        asyncRecordLevelErrors = errors || {};\n      } else {\n        recordLevelErrors = errors || {};\n      }\n    }), fieldKeys.reduce(function (result, name) {\n      return result.concat(runFieldLevelValidation(fields[name], function (error) {\n        fieldLevelErrors[name] = error;\n      }));\n    }, []));\n    var hasAsyncValidations = promises.length > 0;\n    var asyncValidationPromiseKey = ++nextAsyncValidationKey;\n    var promise = Promise.all(promises).then(clearAsyncValidationPromise(asyncValidationPromiseKey));\n\n    // backwards-compat: add promise to submit-blocking promises iff there are any promises to await\n    if (hasAsyncValidations) {\n      asyncValidationPromises[asyncValidationPromiseKey] = promise;\n    }\n    var processErrors = function processErrors(afterAsync) {\n      var merged = _extends({}, limitedFieldLevelValidation ? formState.errors : {}, recordLevelErrors, afterAsync ? asyncRecordLevelErrors // new async errors\n      : formState.asyncErrors);\n      var forEachError = function forEachError(fn) {\n        fieldKeys.forEach(function (name) {\n          if (fields[name]) {\n            // make sure field is still registered\n            // field-level errors take precedent over record-level errors\n            var recordLevelError = getIn(recordLevelErrors, name);\n            var errorFromParent = getIn(merged, name);\n            var hasFieldLevelValidation = getValidators(safeFields[name]).length;\n            var fieldLevelError = fieldLevelErrors[name];\n            fn(name, hasFieldLevelValidation && fieldLevelError || validate && recordLevelError || (!recordLevelError && !limitedFieldLevelValidation ? errorFromParent : undefined));\n          }\n        });\n      };\n      forEachError(function (name, error) {\n        merged = setIn(merged, name, error) || {};\n      });\n      forEachError(function (name, error) {\n        if (error && error[ARRAY_ERROR]) {\n          var existing = getIn(merged, name);\n          var copy = [].concat(existing);\n          copy[ARRAY_ERROR] = error[ARRAY_ERROR];\n          merged = setIn(merged, name, copy);\n        }\n      });\n      if (!shallowEqual(formState.errors, merged)) {\n        formState.errors = merged;\n      }\n      if (afterAsync) {\n        formState.asyncErrors = asyncRecordLevelErrors;\n      }\n      formState.error = recordLevelErrors[FORM_ERROR];\n    };\n    if (hasAsyncValidations) {\n      // async validations are running, ensure validating is true before notifying\n      state.formState.validating++;\n      callback();\n    }\n\n    // process sync errors\n    processErrors(false);\n    // sync errors have been set. notify listeners while we wait for others\n    callback();\n    if (hasAsyncValidations) {\n      var afterPromise = function afterPromise() {\n        state.formState.validating--;\n        callback();\n        // field async validation may affect formState validating\n        // so force notifyFormListeners if validating is still 0 after callback finished\n        // and lastFormState validating is true\n        if (state.formState.validating === 0 && state.lastFormState.validating) {\n          notifyFormListeners();\n        }\n      };\n      promise.then(function () {\n        if (nextAsyncValidationKey > asyncValidationPromiseKey) {\n          // if this async validator has been superseded by another, ignore its results\n          return;\n        }\n        processErrors(true);\n      }).then(afterPromise, afterPromise);\n    }\n  };\n  var notifyFieldListeners = function notifyFieldListeners(name) {\n    if (inBatch) {\n      return;\n    }\n    var fields = state.fields,\n      fieldSubscribers = state.fieldSubscribers,\n      formState = state.formState;\n    var safeFields = _extends({}, fields);\n    var notifyField = function notifyField(name) {\n      var field = safeFields[name];\n      var fieldState = publishFieldState(formState, field);\n      var lastFieldState = field.lastFieldState;\n      field.lastFieldState = fieldState;\n      var fieldSubscriber = fieldSubscribers[name];\n      if (fieldSubscriber) {\n        notify(fieldSubscriber, fieldState, lastFieldState, filterFieldState, lastFieldState === undefined);\n      }\n    };\n    if (name) {\n      notifyField(name);\n    } else {\n      Object.keys(safeFields).forEach(notifyField);\n    }\n  };\n  var markAllFieldsTouched = function markAllFieldsTouched() {\n    Object.keys(state.fields).forEach(function (key) {\n      state.fields[key].touched = true;\n    });\n  };\n  var hasSyncErrors = function hasSyncErrors() {\n    return !!(state.formState.error || hasAnyError(state.formState.errors));\n  };\n  var calculateNextFormState = function calculateNextFormState() {\n    var fields = state.fields,\n      formState = state.formState,\n      lastFormState = state.lastFormState;\n    var safeFields = _extends({}, fields);\n    var safeFieldKeys = Object.keys(safeFields);\n\n    // calculate dirty/pristine\n    var foundDirty = false;\n    var dirtyFields = safeFieldKeys.reduce(function (result, key) {\n      var dirty = !safeFields[key].isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));\n      if (dirty) {\n        foundDirty = true;\n        result[key] = true;\n      }\n      return result;\n    }, {});\n    var dirtyFieldsSinceLastSubmit = safeFieldKeys.reduce(function (result, key) {\n      // istanbul ignore next\n      var nonNullLastSubmittedValues = formState.lastSubmittedValues || {}; // || {} is for flow, but causes branch coverage complaint\n      if (!safeFields[key].isEqual(getIn(formState.values, key), getIn(nonNullLastSubmittedValues, key))) {\n        result[key] = true;\n      }\n      return result;\n    }, {});\n    formState.pristine = !foundDirty;\n    formState.dirtySinceLastSubmit = !!(formState.lastSubmittedValues && Object.values(dirtyFieldsSinceLastSubmit).some(function (value) {\n      return value;\n    }));\n    formState.modifiedSinceLastSubmit = !!(formState.lastSubmittedValues &&\n    // Object.values would treat values as mixed (facebook/flow#2221)\n    Object.keys(safeFields).some(function (value) {\n      return safeFields[value].modifiedSinceLastSubmit;\n    }));\n    formState.valid = !formState.error && !formState.submitError && !hasAnyError(formState.errors) && !(formState.submitErrors && hasAnyError(formState.submitErrors));\n    var nextFormState = convertToExternalFormState(formState);\n    var _safeFieldKeys$reduce = safeFieldKeys.reduce(function (result, key) {\n        result.modified[key] = safeFields[key].modified;\n        result.touched[key] = safeFields[key].touched;\n        result.visited[key] = safeFields[key].visited;\n        return result;\n      }, {\n        modified: {},\n        touched: {},\n        visited: {}\n      }),\n      modified = _safeFieldKeys$reduce.modified,\n      touched = _safeFieldKeys$reduce.touched,\n      visited = _safeFieldKeys$reduce.visited;\n    nextFormState.dirtyFields = lastFormState && shallowEqual(lastFormState.dirtyFields, dirtyFields) ? lastFormState.dirtyFields : dirtyFields;\n    nextFormState.dirtyFieldsSinceLastSubmit = lastFormState && shallowEqual(lastFormState.dirtyFieldsSinceLastSubmit, dirtyFieldsSinceLastSubmit) ? lastFormState.dirtyFieldsSinceLastSubmit : dirtyFieldsSinceLastSubmit;\n    nextFormState.modified = lastFormState && shallowEqual(lastFormState.modified, modified) ? lastFormState.modified : modified;\n    nextFormState.touched = lastFormState && shallowEqual(lastFormState.touched, touched) ? lastFormState.touched : touched;\n    nextFormState.visited = lastFormState && shallowEqual(lastFormState.visited, visited) ? lastFormState.visited : visited;\n    return lastFormState && shallowEqual(lastFormState, nextFormState) ? lastFormState : nextFormState;\n  };\n  var callDebug = function callDebug() {\n    return debug && \"development\" !== \"production\" && debug(calculateNextFormState(), Object.keys(state.fields).reduce(function (result, key) {\n      result[key] = state.fields[key];\n      return result;\n    }, {}));\n  };\n  var notifying = false;\n  var scheduleNotification = false;\n  var notifyFormListeners = function notifyFormListeners() {\n    if (notifying) {\n      scheduleNotification = true;\n    } else {\n      notifying = true;\n      callDebug();\n      if (!inBatch && !(validationPaused && preventNotificationWhileValidationPaused)) {\n        var lastFormState = state.lastFormState;\n        var nextFormState = calculateNextFormState();\n        if (nextFormState !== lastFormState) {\n          state.lastFormState = nextFormState;\n          notify(state.subscribers, nextFormState, lastFormState, filterFormState);\n        }\n      }\n      notifying = false;\n      if (scheduleNotification) {\n        scheduleNotification = false;\n        notifyFormListeners();\n      }\n    }\n  };\n  var beforeSubmit = function beforeSubmit() {\n    return Object.keys(state.fields).some(function (name) {\n      return state.fields[name].beforeSubmit && state.fields[name].beforeSubmit() === false;\n    });\n  };\n  var afterSubmit = function afterSubmit() {\n    return Object.keys(state.fields).forEach(function (name) {\n      return state.fields[name].afterSubmit && state.fields[name].afterSubmit();\n    });\n  };\n  var resetModifiedAfterSubmit = function resetModifiedAfterSubmit() {\n    return Object.keys(state.fields).forEach(function (key) {\n      return state.fields[key].modifiedSinceLastSubmit = false;\n    });\n  };\n\n  // generate initial errors\n  runValidation(undefined, function () {\n    notifyFormListeners();\n  });\n  var api = {\n    batch: function batch(fn) {\n      inBatch++;\n      fn();\n      inBatch--;\n      notifyFieldListeners();\n      notifyFormListeners();\n    },\n    blur: function blur(name) {\n      var fields = state.fields,\n        formState = state.formState;\n      var previous = fields[name];\n      if (previous) {\n        // can only blur registered fields\n        delete formState.active;\n        fields[name] = _extends({}, previous, {\n          active: false,\n          touched: true\n        });\n        if (validateOnBlur) {\n          runValidation(name, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n        } else {\n          notifyFieldListeners();\n          notifyFormListeners();\n        }\n      }\n    },\n    change: function change(name, value) {\n      var fields = state.fields,\n        formState = state.formState;\n      if (getIn(formState.values, name) !== value) {\n        changeValue(state, name, function () {\n          return value;\n        });\n        var previous = fields[name];\n        if (previous) {\n          // only track modified for registered fields\n          fields[name] = _extends({}, previous, {\n            modified: true,\n            modifiedSinceLastSubmit: !!formState.lastSubmittedValues\n          });\n        }\n        if (validateOnBlur) {\n          notifyFieldListeners();\n          notifyFormListeners();\n        } else {\n          runValidation(name, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n        }\n      }\n    },\n    get destroyOnUnregister() {\n      return !!destroyOnUnregister;\n    },\n    set destroyOnUnregister(value) {\n      destroyOnUnregister = value;\n    },\n    focus: function focus(name) {\n      var field = state.fields[name];\n      if (field && !field.active) {\n        state.formState.active = name;\n        field.active = true;\n        field.visited = true;\n        notifyFieldListeners();\n        notifyFormListeners();\n      }\n    },\n    mutators: mutatorsApi,\n    getFieldState: function getFieldState(name) {\n      var field = state.fields[name];\n      return field && field.lastFieldState;\n    },\n    getRegisteredFields: function getRegisteredFields() {\n      return Object.keys(state.fields);\n    },\n    getState: function getState() {\n      return calculateNextFormState();\n    },\n    initialize: function initialize(data) {\n      var fields = state.fields,\n        formState = state.formState;\n      var safeFields = _extends({}, fields);\n      var values = typeof data === \"function\" ? data(formState.values) : data;\n      if (!keepDirtyOnReinitialize) {\n        formState.values = values;\n      }\n      /**\n       * Hello, inquisitive code reader! Thanks for taking the time to dig in!\n       *\n       * The following code is the way it is to allow for non-registered deep\n       * field values to be set via initialize()\n       */\n\n      // save dirty values\n      var savedDirtyValues = keepDirtyOnReinitialize ? Object.keys(safeFields).reduce(function (result, key) {\n        var field = safeFields[key];\n        var pristine = field.isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));\n        if (!pristine) {\n          result[key] = getIn(formState.values, key);\n        }\n        return result;\n      }, {}) : {};\n      // update initalValues and values\n      formState.initialValues = values;\n      formState.values = values;\n      // restore the dirty values\n      Object.keys(savedDirtyValues).forEach(function (key) {\n        formState.values = setIn(formState.values, key, savedDirtyValues[key]) || {};\n      });\n      runValidation(undefined, function () {\n        notifyFieldListeners();\n        notifyFormListeners();\n      });\n    },\n    isValidationPaused: function isValidationPaused() {\n      return validationPaused;\n    },\n    pauseValidation: function pauseValidation(preventNotification) {\n      if (preventNotification === void 0) {\n        preventNotification = true;\n      }\n      validationPaused = true;\n      preventNotificationWhileValidationPaused = preventNotification;\n    },\n    registerField: function registerField(name, subscriber, subscription, fieldConfig) {\n      if (subscription === void 0) {\n        subscription = {};\n      }\n      if (!state.fieldSubscribers[name]) {\n        state.fieldSubscribers[name] = {\n          index: 0,\n          entries: {}\n        };\n      }\n      var index = state.fieldSubscribers[name].index++;\n\n      // save field subscriber callback\n      state.fieldSubscribers[name].entries[index] = {\n        subscriber: memoize(subscriber),\n        subscription: subscription,\n        notified: false\n      };\n\n      // create initial field state if not exists\n      var field = state.fields[name] || {\n        active: false,\n        afterSubmit: fieldConfig && fieldConfig.afterSubmit,\n        beforeSubmit: fieldConfig && fieldConfig.beforeSubmit,\n        data: fieldConfig && fieldConfig.data || {},\n        isEqual: fieldConfig && fieldConfig.isEqual || tripleEquals,\n        lastFieldState: undefined,\n        modified: false,\n        modifiedSinceLastSubmit: false,\n        name: name,\n        touched: false,\n        valid: true,\n        validateFields: fieldConfig && fieldConfig.validateFields,\n        validators: {},\n        validating: false,\n        visited: false\n      };\n      // Mutators can create a field in order to keep the field states\n      // We must update this field when registerField is called afterwards\n      field.blur = field.blur || function () {\n        return api.blur(name);\n      };\n      field.change = field.change || function (value) {\n        return api.change(name, value);\n      };\n      field.focus = field.focus || function () {\n        return api.focus(name);\n      };\n      state.fields[name] = field;\n      var haveValidator = false;\n      var silent = fieldConfig && fieldConfig.silent;\n      var notify = function notify() {\n        if (silent && state.fields[name]) {\n          notifyFieldListeners(name);\n        } else {\n          notifyFormListeners();\n          notifyFieldListeners();\n        }\n      };\n      if (fieldConfig) {\n        haveValidator = !!(fieldConfig.getValidator && fieldConfig.getValidator());\n        if (fieldConfig.getValidator) {\n          state.fields[name].validators[index] = fieldConfig.getValidator;\n        }\n        var noValueInFormState = getIn(state.formState.values, name) === undefined;\n        if (fieldConfig.initialValue !== undefined && (noValueInFormState || getIn(state.formState.values, name) === getIn(state.formState.initialValues, name))\n        // only initialize if we don't yet have any value for this field\n        ) {\n          state.formState.initialValues = setIn(state.formState.initialValues || {}, name, fieldConfig.initialValue);\n          state.formState.values = setIn(state.formState.values, name, fieldConfig.initialValue);\n          runValidation(undefined, notify);\n        }\n\n        // only use defaultValue if we don't yet have any value for this field\n        if (fieldConfig.defaultValue !== undefined && fieldConfig.initialValue === undefined && getIn(state.formState.initialValues, name) === undefined && noValueInFormState) {\n          state.formState.values = setIn(state.formState.values, name, fieldConfig.defaultValue);\n        }\n      }\n      if (haveValidator) {\n        runValidation(undefined, notify);\n      } else {\n        notify();\n      }\n      return function () {\n        var validatorRemoved = false;\n        // istanbul ignore next\n        if (state.fields[name]) {\n          // state.fields[name] may have been removed by a mutator\n          validatorRemoved = !!(state.fields[name].validators[index] && state.fields[name].validators[index]());\n          delete state.fields[name].validators[index];\n        }\n        var hasFieldSubscribers = !!state.fieldSubscribers[name];\n        if (hasFieldSubscribers) {\n          // state.fieldSubscribers[name] may have been removed by a mutator\n          delete state.fieldSubscribers[name].entries[index];\n        }\n        var lastOne = hasFieldSubscribers && !Object.keys(state.fieldSubscribers[name].entries).length;\n        if (lastOne) {\n          delete state.fieldSubscribers[name];\n          delete state.fields[name];\n          if (validatorRemoved) {\n            state.formState.errors = setIn(state.formState.errors, name, undefined) || {};\n          }\n          if (destroyOnUnregister) {\n            state.formState.values = setIn(state.formState.values, name, undefined, true) || {};\n          }\n        }\n        if (!silent) {\n          if (validatorRemoved) {\n            runValidation(undefined, function () {\n              notifyFormListeners();\n              notifyFieldListeners();\n            });\n          } else if (lastOne) {\n            // values or errors may have changed\n            notifyFormListeners();\n          }\n        }\n      };\n    },\n    reset: function reset(initialValues) {\n      if (initialValues === void 0) {\n        initialValues = state.formState.initialValues;\n      }\n      if (state.formState.submitting) {\n        state.formState.resetWhileSubmitting = true;\n      }\n      state.formState.submitFailed = false;\n      state.formState.submitSucceeded = false;\n      delete state.formState.submitError;\n      delete state.formState.submitErrors;\n      delete state.formState.lastSubmittedValues;\n      api.initialize(initialValues || {});\n    },\n    /**\n     * Resets all field flags (e.g. touched, visited, etc.) to their initial state\n     */\n    resetFieldState: function resetFieldState(name) {\n      state.fields[name] = _extends({}, state.fields[name], {\n        active: false,\n        lastFieldState: undefined,\n        modified: false,\n        touched: false,\n        valid: true,\n        validating: false,\n        visited: false\n      });\n      runValidation(undefined, function () {\n        notifyFieldListeners();\n        notifyFormListeners();\n      });\n    },\n    /**\n     * Returns the form to a clean slate; that is:\n     * - Clear all values\n     * - Resets all fields to their initial state\n     */\n    restart: function restart(initialValues) {\n      if (initialValues === void 0) {\n        initialValues = state.formState.initialValues;\n      }\n      api.batch(function () {\n        for (var name in state.fields) {\n          api.resetFieldState(name);\n          state.fields[name] = _extends({}, state.fields[name], {\n            active: false,\n            lastFieldState: undefined,\n            modified: false,\n            modifiedSinceLastSubmit: false,\n            touched: false,\n            valid: true,\n            validating: false,\n            visited: false\n          });\n        }\n        api.reset(initialValues);\n      });\n    },\n    resumeValidation: function resumeValidation() {\n      validationPaused = false;\n      preventNotificationWhileValidationPaused = false;\n      if (validationBlocked) {\n        // validation was attempted while it was paused, so run it now\n        runValidation(undefined, function () {\n          notifyFieldListeners();\n          notifyFormListeners();\n        });\n      }\n      validationBlocked = false;\n    },\n    setConfig: function setConfig(name, value) {\n      switch (name) {\n        case \"debug\":\n          debug = value;\n          break;\n        case \"destroyOnUnregister\":\n          destroyOnUnregister = value;\n          break;\n        case \"initialValues\":\n          api.initialize(value);\n          break;\n        case \"keepDirtyOnReinitialize\":\n          keepDirtyOnReinitialize = value;\n          break;\n        case \"mutators\":\n          mutators = value;\n          if (value) {\n            Object.keys(mutatorsApi).forEach(function (key) {\n              if (!(key in value)) {\n                delete mutatorsApi[key];\n              }\n            });\n            Object.keys(value).forEach(function (key) {\n              mutatorsApi[key] = getMutatorApi(key);\n            });\n          } else {\n            Object.keys(mutatorsApi).forEach(function (key) {\n              delete mutatorsApi[key];\n            });\n          }\n          break;\n        case \"onSubmit\":\n          onSubmit = value;\n          break;\n        case \"validate\":\n          validate = value;\n          runValidation(undefined, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n          break;\n        case \"validateOnBlur\":\n          validateOnBlur = value;\n          break;\n        default:\n          throw new Error(\"Unrecognised option \" + name);\n      }\n    },\n    submit: function submit() {\n      var formState = state.formState;\n      if (formState.submitting) {\n        return;\n      }\n      delete formState.submitErrors;\n      delete formState.submitError;\n      formState.lastSubmittedValues = _extends({}, formState.values);\n      if (hasSyncErrors()) {\n        markAllFieldsTouched();\n        resetModifiedAfterSubmit();\n        state.formState.submitFailed = true;\n        notifyFormListeners();\n        notifyFieldListeners();\n        return; // no submit for you!!\n      }\n\n      var asyncValidationPromisesKeys = Object.keys(asyncValidationPromises);\n      if (asyncValidationPromisesKeys.length) {\n        // still waiting on async validation to complete...\n        Promise.all(asyncValidationPromisesKeys.map(function (key) {\n          return asyncValidationPromises[Number(key)];\n        })).then(api.submit, console.error);\n        return;\n      }\n      var submitIsBlocked = beforeSubmit();\n      if (submitIsBlocked) {\n        return;\n      }\n      var resolvePromise;\n      var completeCalled = false;\n      var complete = function complete(errors) {\n        formState.submitting = false;\n        var resetWhileSubmitting = formState.resetWhileSubmitting;\n        if (resetWhileSubmitting) {\n          formState.resetWhileSubmitting = false;\n        }\n        if (errors && hasAnyError(errors)) {\n          formState.submitFailed = true;\n          formState.submitSucceeded = false;\n          formState.submitErrors = errors;\n          formState.submitError = errors[FORM_ERROR];\n          markAllFieldsTouched();\n        } else {\n          if (!resetWhileSubmitting) {\n            formState.submitFailed = false;\n            formState.submitSucceeded = true;\n          }\n          afterSubmit();\n        }\n        notifyFormListeners();\n        notifyFieldListeners();\n        completeCalled = true;\n        if (resolvePromise) {\n          resolvePromise(errors);\n        }\n        return errors;\n      };\n      formState.submitting = true;\n      formState.submitFailed = false;\n      formState.submitSucceeded = false;\n      formState.lastSubmittedValues = _extends({}, formState.values);\n      resetModifiedAfterSubmit();\n\n      // onSubmit is either sync, callback or async with a Promise\n      var result = onSubmit(formState.values, api, complete);\n      if (!completeCalled) {\n        if (result && isPromise(result)) {\n          // onSubmit is async with a Promise\n          notifyFormListeners(); // let everyone know we are submitting\n          notifyFieldListeners(); // notify fields also\n          return result.then(complete, function (error) {\n            complete();\n            throw error;\n          });\n        } else if (onSubmit.length >= 3) {\n          // must be async, so we should return a Promise\n          notifyFormListeners(); // let everyone know we are submitting\n          notifyFieldListeners(); // notify fields also\n          return new Promise(function (resolve) {\n            resolvePromise = resolve;\n          });\n        } else {\n          // onSubmit is sync\n          complete(result);\n        }\n      }\n    },\n    subscribe: function subscribe(subscriber, subscription) {\n      if (!subscriber) {\n        throw new Error(\"No callback given.\");\n      }\n      if (!subscription) {\n        throw new Error(\"No subscription provided. What values do you want to listen to?\");\n      }\n      var memoized = memoize(subscriber);\n      var subscribers = state.subscribers;\n      var index = subscribers.index++;\n      subscribers.entries[index] = {\n        subscriber: memoized,\n        subscription: subscription,\n        notified: false\n      };\n      var nextFormState = calculateNextFormState();\n      notifySubscriber(memoized, subscription, nextFormState, nextFormState, filterFormState, true);\n      return function () {\n        delete subscribers.entries[index];\n      };\n    }\n  };\n  return api;\n}\nexport { ARRAY_ERROR, FORM_ERROR, configOptions, createForm, fieldSubscriptionItems, formSubscriptionItems, getIn, setIn, version };","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","RegExp","stringToPath","string","result","push","replace","match","expression","quote","subString","key","trim","keysCache","keysRegex","toPath","undefined","length","Error","endsWith","split","filter","Boolean","getIn","state","complexKey","path","current","i","Array","isArray","isNaN","_toPropertyKey","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","res","call","TypeError","Number","setInRecursor","index","value","destroyArrays","_extends2","_ref","_result","_result2","numKeys","Object","keys","_final","map","numericKey","_result3","_array","existingValue","array","concat","splice","setIn","FORM_ERROR","ARRAY_ERROR","publishFieldState","formState","field","errors","initialValues","lastSubmittedValues","submitErrors","submitFailed","submitSucceeded","submitting","values","active","blur","change","data","focus","modified","modifiedSinceLastSubmit","name","touched","validating","visited","error","submitError","initial","pristine","isEqual","dirtySinceLastSubmit","valid","dirty","invalid","fieldSubscriptionItems","shallowEqual","a","b","keysA","keysB","bHasOwnProperty","prototype","hasOwnProperty","bind","idx","subscriptionFilter","dest","src","previous","subscription","shallowEqualKeys","different","forEach","indexOf","shallowEqualKeys$1","filterFieldState","previousState","force","formSubscriptionItems","filterFormState","memoize","fn","lastArgs","lastResult","_len","arguments","args","_key","some","apply","isPromise","obj","then","version","configOptions","tripleEquals","hasAnyError","convertToExternalFormState","hasSubmitErrors","hasValidationErrors","notifySubscriber","subscriber","lastState","notification","notify","_ref2","entries","entry","notified","createForm","config","debug","destroyOnUnregister","keepDirtyOnReinitialize","mutators","onSubmit","validate","validateOnBlur","subscribers","fieldSubscribers","fields","asyncErrors","resetWhileSubmitting","lastFormState","inBatch","validationPaused","validationBlocked","preventNotificationWhileValidationPaused","nextAsyncValidationKey","asyncValidationPromises","clearAsyncValidationPromise","changeValue","mutate","before","after","renameField","from","to","_extends3","api","lastFieldState","getMutatorApi","mutatableState","returnValue","resetFieldState","runValidation","notifyFieldListeners","notifyFormListeners","mutatorsApi","reduce","runRecordLevelValidation","setErrors","promises","errorsOrPromise","getValidators","validators","validator","runFieldLevelValidation","setError","errorOrPromise","promise","fieldChanged","callback","safeFields","fieldKeys","limitedFieldLevelValidation","changedField","validateFields","recordLevelErrors","asyncRecordLevelErrors","fieldLevelErrors","wasAsync","hasAsyncValidations","asyncValidationPromiseKey","Promise","all","processErrors","afterAsync","merged","forEachError","recordLevelError","errorFromParent","hasFieldLevelValidation","fieldLevelError","existing","copy","afterPromise","notifyField","fieldState","fieldSubscriber","markAllFieldsTouched","hasSyncErrors","calculateNextFormState","safeFieldKeys","foundDirty","dirtyFields","dirtyFieldsSinceLastSubmit","nonNullLastSubmittedValues","nextFormState","_safeFieldKeys$reduce","callDebug","notifying","scheduleNotification","beforeSubmit","afterSubmit","resetModifiedAfterSubmit","batch","getFieldState","getRegisteredFields","getState","initialize","savedDirtyValues","isValidationPaused","pauseValidation","preventNotification","registerField","fieldConfig","haveValidator","silent","getValidator","noValueInFormState","initialValue","defaultValue","validatorRemoved","hasFieldSubscribers","lastOne","reset","restart","resumeValidation","setConfig","submit","asyncValidationPromisesKeys","console","submitIsBlocked","resolvePromise","completeCalled","complete","resolve","subscribe","memoized"],"sources":["C:/Users/VishwajithJayasinghe/Documents/MyDocs/Projects/React-front-end/node_modules/final-form/dist/final-form.es.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n//      \n\nvar charCodeOfDot = \".\".charCodeAt(0);\nvar reEscapeChar = /\\\\(\\\\)?/g;\nvar rePropName = RegExp(\n// Match anything that isn't a dot or bracket.\n\"[^.[\\\\]]+\" + \"|\" +\n// Or match property names within brackets.\n\"\\\\[(?:\" +\n// Match a non-string expression.\n\"([^\\\"'][^[]*)\" + \"|\" +\n// Or match strings (supports escaping characters).\n\"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" + \")\\\\]\" + \"|\" +\n// Or match \"\" as the space between consecutive dots or empty brackets.\n\"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\", \"g\");\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = function stringToPath(string) {\n  var result = [];\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push(\"\");\n  }\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    var key = match;\n    if (quote) {\n      key = subString.replace(reEscapeChar, \"$1\");\n    } else if (expression) {\n      key = expression.trim();\n    }\n    result.push(key);\n  });\n  return result;\n};\nvar keysCache = {};\nvar keysRegex = /[.[\\]]+/;\nvar toPath = function toPath(key) {\n  if (key === null || key === undefined || !key.length) {\n    return [];\n  }\n  if (typeof key !== \"string\") {\n    throw new Error(\"toPath() expects a string\");\n  }\n  if (keysCache[key] == null) {\n    /**\n     * The following patch fixes issue 456, introduced since v4.20.3:\n     *\n     * Before v4.20.3, i.e. in v4.20.2, a `key` like 'choices[]' would map to ['choices']\n     * (e.g. an array of choices used where 'choices[]' is name attribute of an input of type checkbox).\n     *\n     * Since v4.20.3, a `key` like 'choices[]' would map to ['choices', ''] which is wrong and breaks\n     * this kind of inputs e.g. in React.\n     *\n     * v4.20.3 introduced an unwanted breaking change, this patch fixes it, see the issue at the link below.\n     *\n     * @see https://github.com/final-form/final-form/issues/456\n     */\n    if (key.endsWith(\"[]\")) {\n      // v4.20.2 (a `key` like 'choices[]' should map to ['choices'], which is fine).\n      keysCache[key] = key.split(keysRegex).filter(Boolean);\n    } else {\n      // v4.20.3 (a `key` like 'choices[]' maps to ['choices', ''], which breaks applications relying on inputs like `<input type=\"checkbox\" name=\"choices[]\" />`).\n      keysCache[key] = stringToPath(key);\n    }\n  }\n  return keysCache[key];\n};\n\n//      \nvar getIn = function getIn(state, complexKey) {\n  // Intentionally using iteration rather than recursion\n  var path = toPath(complexKey);\n  var current = state;\n  for (var i = 0; i < path.length; i++) {\n    var key = path[i];\n    if (current === undefined || current === null || typeof current !== \"object\" || Array.isArray(current) && isNaN(key)) {\n      return undefined;\n    }\n    current = current[key];\n  }\n  return current;\n};\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar setInRecursor = function setInRecursor(current, index, path, value, destroyArrays) {\n  if (index >= path.length) {\n    // end of recursion\n    return value;\n  }\n  var key = path[index];\n\n  // determine type of key\n  if (isNaN(key)) {\n    var _extends2;\n    // object set\n    if (current === undefined || current === null) {\n      var _ref;\n      // recurse\n      var _result = setInRecursor(undefined, index + 1, path, value, destroyArrays);\n\n      // delete or create an object\n      return _result === undefined ? undefined : (_ref = {}, _ref[key] = _result, _ref);\n    }\n    if (Array.isArray(current)) {\n      throw new Error(\"Cannot set a non-numeric property on an array\");\n    }\n    // current exists, so make a copy of all its values, and add/update the new one\n    var _result2 = setInRecursor(current[key], index + 1, path, value, destroyArrays);\n    if (_result2 === undefined) {\n      var numKeys = Object.keys(current).length;\n      if (current[key] === undefined && numKeys === 0) {\n        // object was already empty\n        return undefined;\n      }\n      if (current[key] !== undefined && numKeys <= 1) {\n        // only key we had was the one we are deleting\n        if (!isNaN(path[index - 1]) && !destroyArrays) {\n          // we are in an array, so return an empty object\n          return {};\n        } else {\n          return undefined;\n        }\n      }\n      current[key];\n        var _final = _objectWithoutPropertiesLoose(current, [key].map(_toPropertyKey));\n      return _final;\n    }\n    // set result in key\n    return _extends({}, current, (_extends2 = {}, _extends2[key] = _result2, _extends2));\n  }\n  // array set\n  var numericKey = Number(key);\n  if (current === undefined || current === null) {\n    // recurse\n    var _result3 = setInRecursor(undefined, index + 1, path, value, destroyArrays);\n\n    // if nothing returned, delete it\n    if (_result3 === undefined) {\n      return undefined;\n    }\n\n    // create an array\n    var _array = [];\n    _array[numericKey] = _result3;\n    return _array;\n  }\n  if (!Array.isArray(current)) {\n    throw new Error(\"Cannot set a numeric property on an object\");\n  }\n  // recurse\n  var existingValue = current[numericKey];\n  var result = setInRecursor(existingValue, index + 1, path, value, destroyArrays);\n\n  // current exists, so make a copy of all its values, and add/update the new one\n  var array = [].concat(current);\n  if (destroyArrays && result === undefined) {\n    array.splice(numericKey, 1);\n    if (array.length === 0) {\n      return undefined;\n    }\n  } else {\n    array[numericKey] = result;\n  }\n  return array;\n};\nvar setIn = function setIn(state, key, value, destroyArrays) {\n  if (destroyArrays === void 0) {\n    destroyArrays = false;\n  }\n  if (state === undefined || state === null) {\n    throw new Error(\"Cannot call setIn() with \" + String(state) + \" state\");\n  }\n  if (key === undefined || key === null) {\n    throw new Error(\"Cannot call setIn() with \" + String(key) + \" key\");\n  }\n  // Recursive function needs to accept and return State, but public API should\n  // only deal with Objects\n  return setInRecursor(state, 0, toPath(key), value, destroyArrays);\n};\n\nvar FORM_ERROR = \"FINAL_FORM/form-error\";\nvar ARRAY_ERROR = \"FINAL_FORM/array-error\";\n\n//      \n\n\n/**\n * Converts internal field state to published field state\n */\nfunction publishFieldState(formState, field) {\n  var errors = formState.errors,\n    initialValues = formState.initialValues,\n    lastSubmittedValues = formState.lastSubmittedValues,\n    submitErrors = formState.submitErrors,\n    submitFailed = formState.submitFailed,\n    submitSucceeded = formState.submitSucceeded,\n    submitting = formState.submitting,\n    values = formState.values;\n  var active = field.active,\n    blur = field.blur,\n    change = field.change,\n    data = field.data,\n    focus = field.focus,\n    modified = field.modified,\n    modifiedSinceLastSubmit = field.modifiedSinceLastSubmit,\n    name = field.name,\n    touched = field.touched,\n    validating = field.validating,\n    visited = field.visited;\n  var value = getIn(values, name);\n  var error = getIn(errors, name);\n  if (error && error[ARRAY_ERROR]) {\n    error = error[ARRAY_ERROR];\n  }\n  var submitError = submitErrors && getIn(submitErrors, name);\n  var initial = initialValues && getIn(initialValues, name);\n  var pristine = field.isEqual(initial, value);\n  var dirtySinceLastSubmit = !!(lastSubmittedValues && !field.isEqual(getIn(lastSubmittedValues, name), value));\n  var valid = !error && !submitError;\n  return {\n    active: active,\n    blur: blur,\n    change: change,\n    data: data,\n    dirty: !pristine,\n    dirtySinceLastSubmit: dirtySinceLastSubmit,\n    error: error,\n    focus: focus,\n    initial: initial,\n    invalid: !valid,\n    length: Array.isArray(value) ? value.length : undefined,\n    modified: modified,\n    modifiedSinceLastSubmit: modifiedSinceLastSubmit,\n    name: name,\n    pristine: pristine,\n    submitError: submitError,\n    submitFailed: submitFailed,\n    submitSucceeded: submitSucceeded,\n    submitting: submitting,\n    touched: touched,\n    valid: valid,\n    value: value,\n    visited: visited,\n    validating: validating\n  };\n}\n\n//      \nvar fieldSubscriptionItems = [\"active\", \"data\", \"dirty\", \"dirtySinceLastSubmit\", \"error\", \"initial\", \"invalid\", \"length\", \"modified\", \"modifiedSinceLastSubmit\", \"pristine\", \"submitError\", \"submitFailed\", \"submitSucceeded\", \"submitting\", \"touched\", \"valid\", \"value\", \"visited\", \"validating\"];\n\n//      \n\nvar shallowEqual = function shallowEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== \"object\" || !a || typeof b !== \"object\" || !b) {\n    return false;\n  }\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b);\n  for (var idx = 0; idx < keysA.length; idx++) {\n    var key = keysA[idx];\n    if (!bHasOwnProperty(key) || a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n//      \nfunction subscriptionFilter (dest, src, previous, subscription, keys, shallowEqualKeys) {\n  var different = false;\n  keys.forEach(function (key) {\n    if (subscription[key]) {\n      dest[key] = src[key];\n      if (!previous || (~shallowEqualKeys.indexOf(key) ? !shallowEqual(src[key], previous[key]) : src[key] !== previous[key])) {\n        different = true;\n      }\n    }\n  });\n  return different;\n}\n\n//      \nvar shallowEqualKeys$1 = [\"data\"];\n\n/**\n * Filters items in a FieldState based on a FieldSubscription\n */\nvar filterFieldState = function filterFieldState(state, previousState, subscription, force) {\n  var result = {\n    blur: state.blur,\n    change: state.change,\n    focus: state.focus,\n    name: state.name\n  };\n  var different = subscriptionFilter(result, state, previousState, subscription, fieldSubscriptionItems, shallowEqualKeys$1) || !previousState;\n  return different || force ? result : undefined;\n};\n\n//      \nvar formSubscriptionItems = [\"active\", \"dirty\", \"dirtyFields\", \"dirtyFieldsSinceLastSubmit\", \"dirtySinceLastSubmit\", \"error\", \"errors\", \"hasSubmitErrors\", \"hasValidationErrors\", \"initialValues\", \"invalid\", \"modified\", \"modifiedSinceLastSubmit\", \"pristine\", \"submitting\", \"submitError\", \"submitErrors\", \"submitFailed\", \"submitSucceeded\", \"touched\", \"valid\", \"validating\", \"values\", \"visited\"];\n\n//      \nvar shallowEqualKeys = [\"touched\", \"visited\"];\n\n/**\n * Filters items in a FormState based on a FormSubscription\n */\nfunction filterFormState(state, previousState, subscription, force) {\n  var result = {};\n  var different = subscriptionFilter(result, state, previousState, subscription, formSubscriptionItems, shallowEqualKeys) || !previousState;\n  return different || force ? result : undefined;\n}\n\n//      \nvar memoize = function memoize(fn) {\n  var lastArgs;\n  var lastResult;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (!lastArgs || args.length !== lastArgs.length || args.some(function (arg, index) {\n      return !shallowEqual(lastArgs[index], arg);\n    })) {\n      lastArgs = args;\n      lastResult = fn.apply(void 0, args);\n    }\n    return lastResult;\n  };\n};\n\nvar isPromise = (function (obj) {\n  return !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof obj.then === \"function\";\n});\n\nvar version = \"4.20.10\";\n\nvar configOptions = [\"debug\", \"initialValues\", \"keepDirtyOnReinitialize\", \"mutators\", \"onSubmit\", \"validate\", \"validateOnBlur\"];\nvar tripleEquals = function tripleEquals(a, b) {\n  return a === b;\n};\nvar hasAnyError = function hasAnyError(errors) {\n  return Object.keys(errors).some(function (key) {\n    var value = errors[key];\n    if (value && typeof value === \"object\" && !(value instanceof Error)) {\n      return hasAnyError(value);\n    }\n    return typeof value !== \"undefined\";\n  });\n};\nfunction convertToExternalFormState(_ref) {\n  var active = _ref.active,\n    dirtySinceLastSubmit = _ref.dirtySinceLastSubmit,\n    modifiedSinceLastSubmit = _ref.modifiedSinceLastSubmit,\n    error = _ref.error,\n    errors = _ref.errors,\n    initialValues = _ref.initialValues,\n    pristine = _ref.pristine,\n    submitting = _ref.submitting,\n    submitFailed = _ref.submitFailed,\n    submitSucceeded = _ref.submitSucceeded,\n    submitError = _ref.submitError,\n    submitErrors = _ref.submitErrors,\n    valid = _ref.valid,\n    validating = _ref.validating,\n    values = _ref.values;\n  return {\n    active: active,\n    dirty: !pristine,\n    dirtySinceLastSubmit: dirtySinceLastSubmit,\n    modifiedSinceLastSubmit: modifiedSinceLastSubmit,\n    error: error,\n    errors: errors,\n    hasSubmitErrors: !!(submitError || submitErrors && hasAnyError(submitErrors)),\n    hasValidationErrors: !!(error || hasAnyError(errors)),\n    invalid: !valid,\n    initialValues: initialValues,\n    pristine: pristine,\n    submitting: submitting,\n    submitFailed: submitFailed,\n    submitSucceeded: submitSucceeded,\n    submitError: submitError,\n    submitErrors: submitErrors,\n    valid: valid,\n    validating: validating > 0,\n    values: values\n  };\n}\nfunction notifySubscriber(subscriber, subscription, state, lastState, filter, force) {\n  var notification = filter(state, lastState, subscription, force);\n  if (notification) {\n    subscriber(notification);\n    return true;\n  }\n  return false;\n}\nfunction notify(_ref2, state, lastState, filter, force) {\n  var entries = _ref2.entries;\n  Object.keys(entries).forEach(function (key) {\n    var entry = entries[Number(key)];\n    // istanbul ignore next\n    if (entry) {\n      var subscription = entry.subscription,\n        subscriber = entry.subscriber,\n        notified = entry.notified;\n      if (notifySubscriber(subscriber, subscription, state, lastState, filter, force || !notified)) {\n        entry.notified = true;\n      }\n    }\n  });\n}\nfunction createForm(config) {\n  if (!config) {\n    throw new Error(\"No config specified\");\n  }\n  var debug = config.debug,\n    destroyOnUnregister = config.destroyOnUnregister,\n    keepDirtyOnReinitialize = config.keepDirtyOnReinitialize,\n    initialValues = config.initialValues,\n    mutators = config.mutators,\n    onSubmit = config.onSubmit,\n    validate = config.validate,\n    validateOnBlur = config.validateOnBlur;\n  if (!onSubmit) {\n    throw new Error(\"No onSubmit function specified\");\n  }\n  var state = {\n    subscribers: {\n      index: 0,\n      entries: {}\n    },\n    fieldSubscribers: {},\n    fields: {},\n    formState: {\n      asyncErrors: {},\n      dirtySinceLastSubmit: false,\n      modifiedSinceLastSubmit: false,\n      errors: {},\n      initialValues: initialValues && _extends({}, initialValues),\n      invalid: false,\n      pristine: true,\n      submitting: false,\n      submitFailed: false,\n      submitSucceeded: false,\n      resetWhileSubmitting: false,\n      valid: true,\n      validating: 0,\n      values: initialValues ? _extends({}, initialValues) : {}\n    },\n    lastFormState: undefined\n  };\n  var inBatch = 0;\n  var validationPaused = false;\n  var validationBlocked = false;\n  var preventNotificationWhileValidationPaused = false;\n  var nextAsyncValidationKey = 0;\n  var asyncValidationPromises = {};\n  var clearAsyncValidationPromise = function clearAsyncValidationPromise(key) {\n    return function (result) {\n      delete asyncValidationPromises[key];\n      return result;\n    };\n  };\n  var changeValue = function changeValue(state, name, mutate) {\n    var before = getIn(state.formState.values, name);\n    var after = mutate(before);\n    state.formState.values = setIn(state.formState.values, name, after) || {};\n  };\n  var renameField = function renameField(state, from, to) {\n    if (state.fields[from]) {\n      var _extends2, _extends3;\n      state.fields = _extends({}, state.fields, (_extends2 = {}, _extends2[to] = _extends({}, state.fields[from], {\n        name: to,\n        // rebind event handlers\n        blur: function blur() {\n          return api.blur(to);\n        },\n        change: function change(value) {\n          return api.change(to, value);\n        },\n        focus: function focus() {\n          return api.focus(to);\n        },\n        lastFieldState: undefined\n      }), _extends2));\n      delete state.fields[from];\n      state.fieldSubscribers = _extends({}, state.fieldSubscribers, (_extends3 = {}, _extends3[to] = state.fieldSubscribers[from], _extends3));\n      delete state.fieldSubscribers[from];\n      var value = getIn(state.formState.values, from);\n      state.formState.values = setIn(state.formState.values, from, undefined) || {};\n      state.formState.values = setIn(state.formState.values, to, value);\n      delete state.lastFormState;\n    }\n  };\n\n  // bind state to mutators\n  var getMutatorApi = function getMutatorApi(key) {\n    return function () {\n      // istanbul ignore next\n      if (mutators) {\n        // ^^ causes branch coverage warning, but needed to appease the Flow gods\n        var mutatableState = {\n          formState: state.formState,\n          fields: state.fields,\n          fieldSubscribers: state.fieldSubscribers,\n          lastFormState: state.lastFormState\n        };\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var returnValue = mutators[key](args, mutatableState, {\n          changeValue: changeValue,\n          getIn: getIn,\n          renameField: renameField,\n          resetFieldState: api.resetFieldState,\n          setIn: setIn,\n          shallowEqual: shallowEqual\n        });\n        state.formState = mutatableState.formState;\n        state.fields = mutatableState.fields;\n        state.fieldSubscribers = mutatableState.fieldSubscribers;\n        state.lastFormState = mutatableState.lastFormState;\n        runValidation(undefined, function () {\n          notifyFieldListeners();\n          notifyFormListeners();\n        });\n        return returnValue;\n      }\n    };\n  };\n  var mutatorsApi = mutators ? Object.keys(mutators).reduce(function (result, key) {\n    result[key] = getMutatorApi(key);\n    return result;\n  }, {}) : {};\n  var runRecordLevelValidation = function runRecordLevelValidation(setErrors) {\n    var promises = [];\n    if (validate) {\n      var errorsOrPromise = validate(_extends({}, state.formState.values)); // clone to avoid writing\n      if (isPromise(errorsOrPromise)) {\n        promises.push(errorsOrPromise.then(function (errors) {\n          return setErrors(errors, true);\n        }));\n      } else {\n        setErrors(errorsOrPromise, false);\n      }\n    }\n    return promises;\n  };\n  var getValidators = function getValidators(field) {\n    return Object.keys(field.validators).reduce(function (result, index) {\n      var validator = field.validators[Number(index)]();\n      if (validator) {\n        result.push(validator);\n      }\n      return result;\n    }, []);\n  };\n  var runFieldLevelValidation = function runFieldLevelValidation(field, setError) {\n    var promises = [];\n    var validators = getValidators(field);\n    if (validators.length) {\n      var error;\n      validators.forEach(function (validator) {\n        var errorOrPromise = validator(getIn(state.formState.values, field.name), state.formState.values, validator.length === 0 || validator.length === 3 ? publishFieldState(state.formState, state.fields[field.name]) : undefined);\n        if (errorOrPromise && isPromise(errorOrPromise)) {\n          field.validating = true;\n          var promise = errorOrPromise.then(function (error) {\n            if (state.fields[field.name]) {\n              state.fields[field.name].validating = false;\n              setError(error);\n            }\n          }); // errors must be resolved, not rejected\n          promises.push(promise);\n        } else if (!error) {\n          // first registered validator wins\n          error = errorOrPromise;\n        }\n      });\n      setError(error);\n    }\n    return promises;\n  };\n  var runValidation = function runValidation(fieldChanged, callback) {\n    if (validationPaused) {\n      validationBlocked = true;\n      callback();\n      return;\n    }\n    var fields = state.fields,\n      formState = state.formState;\n    var safeFields = _extends({}, fields);\n    var fieldKeys = Object.keys(safeFields);\n    if (!validate && !fieldKeys.some(function (key) {\n      return getValidators(safeFields[key]).length;\n    })) {\n      callback();\n      return; // no validation rules\n    }\n\n    // pare down field keys to actually validate\n    var limitedFieldLevelValidation = false;\n    if (fieldChanged) {\n      var changedField = safeFields[fieldChanged];\n      if (changedField) {\n        var validateFields = changedField.validateFields;\n        if (validateFields) {\n          limitedFieldLevelValidation = true;\n          fieldKeys = validateFields.length ? validateFields.concat(fieldChanged) : [fieldChanged];\n        }\n      }\n    }\n    var recordLevelErrors = {};\n    var asyncRecordLevelErrors = {};\n    var fieldLevelErrors = {};\n    var promises = [].concat(runRecordLevelValidation(function (errors, wasAsync) {\n      if (wasAsync) {\n        asyncRecordLevelErrors = errors || {};\n      } else {\n        recordLevelErrors = errors || {};\n      }\n    }), fieldKeys.reduce(function (result, name) {\n      return result.concat(runFieldLevelValidation(fields[name], function (error) {\n        fieldLevelErrors[name] = error;\n      }));\n    }, []));\n    var hasAsyncValidations = promises.length > 0;\n    var asyncValidationPromiseKey = ++nextAsyncValidationKey;\n    var promise = Promise.all(promises).then(clearAsyncValidationPromise(asyncValidationPromiseKey));\n\n    // backwards-compat: add promise to submit-blocking promises iff there are any promises to await\n    if (hasAsyncValidations) {\n      asyncValidationPromises[asyncValidationPromiseKey] = promise;\n    }\n    var processErrors = function processErrors(afterAsync) {\n      var merged = _extends({}, limitedFieldLevelValidation ? formState.errors : {}, recordLevelErrors, afterAsync ? asyncRecordLevelErrors // new async errors\n      : formState.asyncErrors);\n      var forEachError = function forEachError(fn) {\n        fieldKeys.forEach(function (name) {\n          if (fields[name]) {\n            // make sure field is still registered\n            // field-level errors take precedent over record-level errors\n            var recordLevelError = getIn(recordLevelErrors, name);\n            var errorFromParent = getIn(merged, name);\n            var hasFieldLevelValidation = getValidators(safeFields[name]).length;\n            var fieldLevelError = fieldLevelErrors[name];\n            fn(name, hasFieldLevelValidation && fieldLevelError || validate && recordLevelError || (!recordLevelError && !limitedFieldLevelValidation ? errorFromParent : undefined));\n          }\n        });\n      };\n      forEachError(function (name, error) {\n        merged = setIn(merged, name, error) || {};\n      });\n      forEachError(function (name, error) {\n        if (error && error[ARRAY_ERROR]) {\n          var existing = getIn(merged, name);\n          var copy = [].concat(existing);\n          copy[ARRAY_ERROR] = error[ARRAY_ERROR];\n          merged = setIn(merged, name, copy);\n        }\n      });\n      if (!shallowEqual(formState.errors, merged)) {\n        formState.errors = merged;\n      }\n      if (afterAsync) {\n        formState.asyncErrors = asyncRecordLevelErrors;\n      }\n      formState.error = recordLevelErrors[FORM_ERROR];\n    };\n    if (hasAsyncValidations) {\n      // async validations are running, ensure validating is true before notifying\n      state.formState.validating++;\n      callback();\n    }\n\n    // process sync errors\n    processErrors(false);\n    // sync errors have been set. notify listeners while we wait for others\n    callback();\n    if (hasAsyncValidations) {\n      var afterPromise = function afterPromise() {\n        state.formState.validating--;\n        callback();\n        // field async validation may affect formState validating\n        // so force notifyFormListeners if validating is still 0 after callback finished\n        // and lastFormState validating is true\n        if (state.formState.validating === 0 && state.lastFormState.validating) {\n          notifyFormListeners();\n        }\n      };\n      promise.then(function () {\n        if (nextAsyncValidationKey > asyncValidationPromiseKey) {\n          // if this async validator has been superseded by another, ignore its results\n          return;\n        }\n        processErrors(true);\n      }).then(afterPromise, afterPromise);\n    }\n  };\n  var notifyFieldListeners = function notifyFieldListeners(name) {\n    if (inBatch) {\n      return;\n    }\n    var fields = state.fields,\n      fieldSubscribers = state.fieldSubscribers,\n      formState = state.formState;\n    var safeFields = _extends({}, fields);\n    var notifyField = function notifyField(name) {\n      var field = safeFields[name];\n      var fieldState = publishFieldState(formState, field);\n      var lastFieldState = field.lastFieldState;\n      field.lastFieldState = fieldState;\n      var fieldSubscriber = fieldSubscribers[name];\n      if (fieldSubscriber) {\n        notify(fieldSubscriber, fieldState, lastFieldState, filterFieldState, lastFieldState === undefined);\n      }\n    };\n    if (name) {\n      notifyField(name);\n    } else {\n      Object.keys(safeFields).forEach(notifyField);\n    }\n  };\n  var markAllFieldsTouched = function markAllFieldsTouched() {\n    Object.keys(state.fields).forEach(function (key) {\n      state.fields[key].touched = true;\n    });\n  };\n  var hasSyncErrors = function hasSyncErrors() {\n    return !!(state.formState.error || hasAnyError(state.formState.errors));\n  };\n  var calculateNextFormState = function calculateNextFormState() {\n    var fields = state.fields,\n      formState = state.formState,\n      lastFormState = state.lastFormState;\n    var safeFields = _extends({}, fields);\n    var safeFieldKeys = Object.keys(safeFields);\n\n    // calculate dirty/pristine\n    var foundDirty = false;\n    var dirtyFields = safeFieldKeys.reduce(function (result, key) {\n      var dirty = !safeFields[key].isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));\n      if (dirty) {\n        foundDirty = true;\n        result[key] = true;\n      }\n      return result;\n    }, {});\n    var dirtyFieldsSinceLastSubmit = safeFieldKeys.reduce(function (result, key) {\n      // istanbul ignore next\n      var nonNullLastSubmittedValues = formState.lastSubmittedValues || {}; // || {} is for flow, but causes branch coverage complaint\n      if (!safeFields[key].isEqual(getIn(formState.values, key), getIn(nonNullLastSubmittedValues, key))) {\n        result[key] = true;\n      }\n      return result;\n    }, {});\n    formState.pristine = !foundDirty;\n    formState.dirtySinceLastSubmit = !!(formState.lastSubmittedValues && Object.values(dirtyFieldsSinceLastSubmit).some(function (value) {\n      return value;\n    }));\n    formState.modifiedSinceLastSubmit = !!(formState.lastSubmittedValues &&\n    // Object.values would treat values as mixed (facebook/flow#2221)\n    Object.keys(safeFields).some(function (value) {\n      return safeFields[value].modifiedSinceLastSubmit;\n    }));\n    formState.valid = !formState.error && !formState.submitError && !hasAnyError(formState.errors) && !(formState.submitErrors && hasAnyError(formState.submitErrors));\n    var nextFormState = convertToExternalFormState(formState);\n    var _safeFieldKeys$reduce = safeFieldKeys.reduce(function (result, key) {\n        result.modified[key] = safeFields[key].modified;\n        result.touched[key] = safeFields[key].touched;\n        result.visited[key] = safeFields[key].visited;\n        return result;\n      }, {\n        modified: {},\n        touched: {},\n        visited: {}\n      }),\n      modified = _safeFieldKeys$reduce.modified,\n      touched = _safeFieldKeys$reduce.touched,\n      visited = _safeFieldKeys$reduce.visited;\n    nextFormState.dirtyFields = lastFormState && shallowEqual(lastFormState.dirtyFields, dirtyFields) ? lastFormState.dirtyFields : dirtyFields;\n    nextFormState.dirtyFieldsSinceLastSubmit = lastFormState && shallowEqual(lastFormState.dirtyFieldsSinceLastSubmit, dirtyFieldsSinceLastSubmit) ? lastFormState.dirtyFieldsSinceLastSubmit : dirtyFieldsSinceLastSubmit;\n    nextFormState.modified = lastFormState && shallowEqual(lastFormState.modified, modified) ? lastFormState.modified : modified;\n    nextFormState.touched = lastFormState && shallowEqual(lastFormState.touched, touched) ? lastFormState.touched : touched;\n    nextFormState.visited = lastFormState && shallowEqual(lastFormState.visited, visited) ? lastFormState.visited : visited;\n    return lastFormState && shallowEqual(lastFormState, nextFormState) ? lastFormState : nextFormState;\n  };\n  var callDebug = function callDebug() {\n    return debug && \"development\" !== \"production\" && debug(calculateNextFormState(), Object.keys(state.fields).reduce(function (result, key) {\n      result[key] = state.fields[key];\n      return result;\n    }, {}));\n  };\n  var notifying = false;\n  var scheduleNotification = false;\n  var notifyFormListeners = function notifyFormListeners() {\n    if (notifying) {\n      scheduleNotification = true;\n    } else {\n      notifying = true;\n      callDebug();\n      if (!inBatch && !(validationPaused && preventNotificationWhileValidationPaused)) {\n        var lastFormState = state.lastFormState;\n        var nextFormState = calculateNextFormState();\n        if (nextFormState !== lastFormState) {\n          state.lastFormState = nextFormState;\n          notify(state.subscribers, nextFormState, lastFormState, filterFormState);\n        }\n      }\n      notifying = false;\n      if (scheduleNotification) {\n        scheduleNotification = false;\n        notifyFormListeners();\n      }\n    }\n  };\n  var beforeSubmit = function beforeSubmit() {\n    return Object.keys(state.fields).some(function (name) {\n      return state.fields[name].beforeSubmit && state.fields[name].beforeSubmit() === false;\n    });\n  };\n  var afterSubmit = function afterSubmit() {\n    return Object.keys(state.fields).forEach(function (name) {\n      return state.fields[name].afterSubmit && state.fields[name].afterSubmit();\n    });\n  };\n  var resetModifiedAfterSubmit = function resetModifiedAfterSubmit() {\n    return Object.keys(state.fields).forEach(function (key) {\n      return state.fields[key].modifiedSinceLastSubmit = false;\n    });\n  };\n\n  // generate initial errors\n  runValidation(undefined, function () {\n    notifyFormListeners();\n  });\n  var api = {\n    batch: function batch(fn) {\n      inBatch++;\n      fn();\n      inBatch--;\n      notifyFieldListeners();\n      notifyFormListeners();\n    },\n    blur: function blur(name) {\n      var fields = state.fields,\n        formState = state.formState;\n      var previous = fields[name];\n      if (previous) {\n        // can only blur registered fields\n        delete formState.active;\n        fields[name] = _extends({}, previous, {\n          active: false,\n          touched: true\n        });\n        if (validateOnBlur) {\n          runValidation(name, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n        } else {\n          notifyFieldListeners();\n          notifyFormListeners();\n        }\n      }\n    },\n    change: function change(name, value) {\n      var fields = state.fields,\n        formState = state.formState;\n      if (getIn(formState.values, name) !== value) {\n        changeValue(state, name, function () {\n          return value;\n        });\n        var previous = fields[name];\n        if (previous) {\n          // only track modified for registered fields\n          fields[name] = _extends({}, previous, {\n            modified: true,\n            modifiedSinceLastSubmit: !!formState.lastSubmittedValues\n          });\n        }\n        if (validateOnBlur) {\n          notifyFieldListeners();\n          notifyFormListeners();\n        } else {\n          runValidation(name, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n        }\n      }\n    },\n    get destroyOnUnregister() {\n      return !!destroyOnUnregister;\n    },\n    set destroyOnUnregister(value) {\n      destroyOnUnregister = value;\n    },\n    focus: function focus(name) {\n      var field = state.fields[name];\n      if (field && !field.active) {\n        state.formState.active = name;\n        field.active = true;\n        field.visited = true;\n        notifyFieldListeners();\n        notifyFormListeners();\n      }\n    },\n    mutators: mutatorsApi,\n    getFieldState: function getFieldState(name) {\n      var field = state.fields[name];\n      return field && field.lastFieldState;\n    },\n    getRegisteredFields: function getRegisteredFields() {\n      return Object.keys(state.fields);\n    },\n    getState: function getState() {\n      return calculateNextFormState();\n    },\n    initialize: function initialize(data) {\n      var fields = state.fields,\n        formState = state.formState;\n      var safeFields = _extends({}, fields);\n      var values = typeof data === \"function\" ? data(formState.values) : data;\n      if (!keepDirtyOnReinitialize) {\n        formState.values = values;\n      }\n      /**\n       * Hello, inquisitive code reader! Thanks for taking the time to dig in!\n       *\n       * The following code is the way it is to allow for non-registered deep\n       * field values to be set via initialize()\n       */\n\n      // save dirty values\n      var savedDirtyValues = keepDirtyOnReinitialize ? Object.keys(safeFields).reduce(function (result, key) {\n        var field = safeFields[key];\n        var pristine = field.isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));\n        if (!pristine) {\n          result[key] = getIn(formState.values, key);\n        }\n        return result;\n      }, {}) : {};\n      // update initalValues and values\n      formState.initialValues = values;\n      formState.values = values;\n      // restore the dirty values\n      Object.keys(savedDirtyValues).forEach(function (key) {\n        formState.values = setIn(formState.values, key, savedDirtyValues[key]) || {};\n      });\n      runValidation(undefined, function () {\n        notifyFieldListeners();\n        notifyFormListeners();\n      });\n    },\n    isValidationPaused: function isValidationPaused() {\n      return validationPaused;\n    },\n    pauseValidation: function pauseValidation(preventNotification) {\n      if (preventNotification === void 0) {\n        preventNotification = true;\n      }\n      validationPaused = true;\n      preventNotificationWhileValidationPaused = preventNotification;\n    },\n    registerField: function registerField(name, subscriber, subscription, fieldConfig) {\n      if (subscription === void 0) {\n        subscription = {};\n      }\n      if (!state.fieldSubscribers[name]) {\n        state.fieldSubscribers[name] = {\n          index: 0,\n          entries: {}\n        };\n      }\n      var index = state.fieldSubscribers[name].index++;\n\n      // save field subscriber callback\n      state.fieldSubscribers[name].entries[index] = {\n        subscriber: memoize(subscriber),\n        subscription: subscription,\n        notified: false\n      };\n\n      // create initial field state if not exists\n      var field = state.fields[name] || {\n        active: false,\n        afterSubmit: fieldConfig && fieldConfig.afterSubmit,\n        beforeSubmit: fieldConfig && fieldConfig.beforeSubmit,\n        data: fieldConfig && fieldConfig.data || {},\n        isEqual: fieldConfig && fieldConfig.isEqual || tripleEquals,\n        lastFieldState: undefined,\n        modified: false,\n        modifiedSinceLastSubmit: false,\n        name: name,\n        touched: false,\n        valid: true,\n        validateFields: fieldConfig && fieldConfig.validateFields,\n        validators: {},\n        validating: false,\n        visited: false\n      };\n      // Mutators can create a field in order to keep the field states\n      // We must update this field when registerField is called afterwards\n      field.blur = field.blur || function () {\n        return api.blur(name);\n      };\n      field.change = field.change || function (value) {\n        return api.change(name, value);\n      };\n      field.focus = field.focus || function () {\n        return api.focus(name);\n      };\n      state.fields[name] = field;\n      var haveValidator = false;\n      var silent = fieldConfig && fieldConfig.silent;\n      var notify = function notify() {\n        if (silent && state.fields[name]) {\n          notifyFieldListeners(name);\n        } else {\n          notifyFormListeners();\n          notifyFieldListeners();\n        }\n      };\n      if (fieldConfig) {\n        haveValidator = !!(fieldConfig.getValidator && fieldConfig.getValidator());\n        if (fieldConfig.getValidator) {\n          state.fields[name].validators[index] = fieldConfig.getValidator;\n        }\n        var noValueInFormState = getIn(state.formState.values, name) === undefined;\n        if (fieldConfig.initialValue !== undefined && (noValueInFormState || getIn(state.formState.values, name) === getIn(state.formState.initialValues, name))\n        // only initialize if we don't yet have any value for this field\n        ) {\n          state.formState.initialValues = setIn(state.formState.initialValues || {}, name, fieldConfig.initialValue);\n          state.formState.values = setIn(state.formState.values, name, fieldConfig.initialValue);\n          runValidation(undefined, notify);\n        }\n\n        // only use defaultValue if we don't yet have any value for this field\n        if (fieldConfig.defaultValue !== undefined && fieldConfig.initialValue === undefined && getIn(state.formState.initialValues, name) === undefined && noValueInFormState) {\n          state.formState.values = setIn(state.formState.values, name, fieldConfig.defaultValue);\n        }\n      }\n      if (haveValidator) {\n        runValidation(undefined, notify);\n      } else {\n        notify();\n      }\n      return function () {\n        var validatorRemoved = false;\n        // istanbul ignore next\n        if (state.fields[name]) {\n          // state.fields[name] may have been removed by a mutator\n          validatorRemoved = !!(state.fields[name].validators[index] && state.fields[name].validators[index]());\n          delete state.fields[name].validators[index];\n        }\n        var hasFieldSubscribers = !!state.fieldSubscribers[name];\n        if (hasFieldSubscribers) {\n          // state.fieldSubscribers[name] may have been removed by a mutator\n          delete state.fieldSubscribers[name].entries[index];\n        }\n        var lastOne = hasFieldSubscribers && !Object.keys(state.fieldSubscribers[name].entries).length;\n        if (lastOne) {\n          delete state.fieldSubscribers[name];\n          delete state.fields[name];\n          if (validatorRemoved) {\n            state.formState.errors = setIn(state.formState.errors, name, undefined) || {};\n          }\n          if (destroyOnUnregister) {\n            state.formState.values = setIn(state.formState.values, name, undefined, true) || {};\n          }\n        }\n        if (!silent) {\n          if (validatorRemoved) {\n            runValidation(undefined, function () {\n              notifyFormListeners();\n              notifyFieldListeners();\n            });\n          } else if (lastOne) {\n            // values or errors may have changed\n            notifyFormListeners();\n          }\n        }\n      };\n    },\n    reset: function reset(initialValues) {\n      if (initialValues === void 0) {\n        initialValues = state.formState.initialValues;\n      }\n      if (state.formState.submitting) {\n        state.formState.resetWhileSubmitting = true;\n      }\n      state.formState.submitFailed = false;\n      state.formState.submitSucceeded = false;\n      delete state.formState.submitError;\n      delete state.formState.submitErrors;\n      delete state.formState.lastSubmittedValues;\n      api.initialize(initialValues || {});\n    },\n    /**\n     * Resets all field flags (e.g. touched, visited, etc.) to their initial state\n     */\n    resetFieldState: function resetFieldState(name) {\n      state.fields[name] = _extends({}, state.fields[name], {\n        active: false,\n        lastFieldState: undefined,\n        modified: false,\n        touched: false,\n        valid: true,\n        validating: false,\n        visited: false\n      });\n      runValidation(undefined, function () {\n        notifyFieldListeners();\n        notifyFormListeners();\n      });\n    },\n    /**\n     * Returns the form to a clean slate; that is:\n     * - Clear all values\n     * - Resets all fields to their initial state\n     */\n    restart: function restart(initialValues) {\n      if (initialValues === void 0) {\n        initialValues = state.formState.initialValues;\n      }\n      api.batch(function () {\n        for (var name in state.fields) {\n          api.resetFieldState(name);\n          state.fields[name] = _extends({}, state.fields[name], {\n            active: false,\n            lastFieldState: undefined,\n            modified: false,\n            modifiedSinceLastSubmit: false,\n            touched: false,\n            valid: true,\n            validating: false,\n            visited: false\n          });\n        }\n        api.reset(initialValues);\n      });\n    },\n    resumeValidation: function resumeValidation() {\n      validationPaused = false;\n      preventNotificationWhileValidationPaused = false;\n      if (validationBlocked) {\n        // validation was attempted while it was paused, so run it now\n        runValidation(undefined, function () {\n          notifyFieldListeners();\n          notifyFormListeners();\n        });\n      }\n      validationBlocked = false;\n    },\n    setConfig: function setConfig(name, value) {\n      switch (name) {\n        case \"debug\":\n          debug = value;\n          break;\n        case \"destroyOnUnregister\":\n          destroyOnUnregister = value;\n          break;\n        case \"initialValues\":\n          api.initialize(value);\n          break;\n        case \"keepDirtyOnReinitialize\":\n          keepDirtyOnReinitialize = value;\n          break;\n        case \"mutators\":\n          mutators = value;\n          if (value) {\n            Object.keys(mutatorsApi).forEach(function (key) {\n              if (!(key in value)) {\n                delete mutatorsApi[key];\n              }\n            });\n            Object.keys(value).forEach(function (key) {\n              mutatorsApi[key] = getMutatorApi(key);\n            });\n          } else {\n            Object.keys(mutatorsApi).forEach(function (key) {\n              delete mutatorsApi[key];\n            });\n          }\n          break;\n        case \"onSubmit\":\n          onSubmit = value;\n          break;\n        case \"validate\":\n          validate = value;\n          runValidation(undefined, function () {\n            notifyFieldListeners();\n            notifyFormListeners();\n          });\n          break;\n        case \"validateOnBlur\":\n          validateOnBlur = value;\n          break;\n        default:\n          throw new Error(\"Unrecognised option \" + name);\n      }\n    },\n    submit: function submit() {\n      var formState = state.formState;\n      if (formState.submitting) {\n        return;\n      }\n      delete formState.submitErrors;\n      delete formState.submitError;\n      formState.lastSubmittedValues = _extends({}, formState.values);\n      if (hasSyncErrors()) {\n        markAllFieldsTouched();\n        resetModifiedAfterSubmit();\n        state.formState.submitFailed = true;\n        notifyFormListeners();\n        notifyFieldListeners();\n        return; // no submit for you!!\n      }\n\n      var asyncValidationPromisesKeys = Object.keys(asyncValidationPromises);\n      if (asyncValidationPromisesKeys.length) {\n        // still waiting on async validation to complete...\n        Promise.all(asyncValidationPromisesKeys.map(function (key) {\n          return asyncValidationPromises[Number(key)];\n        })).then(api.submit, console.error);\n        return;\n      }\n      var submitIsBlocked = beforeSubmit();\n      if (submitIsBlocked) {\n        return;\n      }\n      var resolvePromise;\n      var completeCalled = false;\n      var complete = function complete(errors) {\n        formState.submitting = false;\n        var resetWhileSubmitting = formState.resetWhileSubmitting;\n        if (resetWhileSubmitting) {\n          formState.resetWhileSubmitting = false;\n        }\n        if (errors && hasAnyError(errors)) {\n          formState.submitFailed = true;\n          formState.submitSucceeded = false;\n          formState.submitErrors = errors;\n          formState.submitError = errors[FORM_ERROR];\n          markAllFieldsTouched();\n        } else {\n          if (!resetWhileSubmitting) {\n            formState.submitFailed = false;\n            formState.submitSucceeded = true;\n          }\n          afterSubmit();\n        }\n        notifyFormListeners();\n        notifyFieldListeners();\n        completeCalled = true;\n        if (resolvePromise) {\n          resolvePromise(errors);\n        }\n        return errors;\n      };\n      formState.submitting = true;\n      formState.submitFailed = false;\n      formState.submitSucceeded = false;\n      formState.lastSubmittedValues = _extends({}, formState.values);\n      resetModifiedAfterSubmit();\n\n      // onSubmit is either sync, callback or async with a Promise\n      var result = onSubmit(formState.values, api, complete);\n      if (!completeCalled) {\n        if (result && isPromise(result)) {\n          // onSubmit is async with a Promise\n          notifyFormListeners(); // let everyone know we are submitting\n          notifyFieldListeners(); // notify fields also\n          return result.then(complete, function (error) {\n            complete();\n            throw error;\n          });\n        } else if (onSubmit.length >= 3) {\n          // must be async, so we should return a Promise\n          notifyFormListeners(); // let everyone know we are submitting\n          notifyFieldListeners(); // notify fields also\n          return new Promise(function (resolve) {\n            resolvePromise = resolve;\n          });\n        } else {\n          // onSubmit is sync\n          complete(result);\n        }\n      }\n    },\n    subscribe: function subscribe(subscriber, subscription) {\n      if (!subscriber) {\n        throw new Error(\"No callback given.\");\n      }\n      if (!subscription) {\n        throw new Error(\"No subscription provided. What values do you want to listen to?\");\n      }\n      var memoized = memoize(subscriber);\n      var subscribers = state.subscribers;\n      var index = subscribers.index++;\n      subscribers.entries[index] = {\n        subscriber: memoized,\n        subscription: subscription,\n        notified: false\n      };\n      var nextFormState = calculateNextFormState();\n      notifySubscriber(memoized, subscription, nextFormState, nextFormState, filterFormState, true);\n      return function () {\n        delete subscribers.entries[index];\n      };\n    }\n  };\n  return api;\n}\n\nexport { ARRAY_ERROR, FORM_ERROR, configOptions, createForm, fieldSubscriptionItems, formSubscriptionItems, getIn, setIn, version };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}